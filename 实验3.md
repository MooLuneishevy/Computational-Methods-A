## 实验内容

实验内容如下：

对于方程 $f(x)=x^2-3x+2=0$ ，可以有以下多种不动点迭代方式：

$$\varphi_1=\frac{x^2+2}{3},\varphi_2=\sqrt{3x-2},\varphi_3=3-\frac{2}{x},\varphi_4=\frac{x^2-2}{2x-3}$$

1. 对于根 $x=2$ ，通过分析 $|\varphi_i'(2)|,i=1,2,3,4$ 来分析各个算法的收敛性。
2. 用程序验证分析的结果。对每种算法画一条曲线：横轴是所选初值，纵轴是达到指定精度所需迭代次数。

## 实验设计

计算给定函数的导数可以得到：

$$\varphi_1'=\frac{2x}{3},\varphi_2'=\frac{3}{2\sqrt{3x-2}},\varphi_3'=\frac{2}{x},\varphi_4'=\frac{1}{2}-\frac{1}{2(2x-3)^2}$$

选取区间 $[1.6,2.5]$ 进行迭代求解，那么可以计算得到各个算法收敛性如下：
1. $\varphi_1'\ge\frac{3.2}{3}>1$ ，发散。
2. $\varphi_2'\le\frac{3}{2\sqrt{2.8}}<1$ ，收敛。
3. $\varphi_3'\le\frac{2}{2.56}<1$ ，收敛。
4. $\varphi_4'\le\frac{1}{2}-\frac{1}{2(5-3)^2}<1$ ，收敛。

随后，使用Octave验证分析结果。在进行实验之前，应当完成以下的工作：
1. 分别实现上面的迭代函数。
2. 实现对于不动点迭代的函数，要求能够判断给定的迭代函数是否收敛发散。
3. 确定实验中的参数，并将程序结果以图像形式展示。

迭代函数的实现应当编写函数<code>function [y]=fi(x)</code>，函数返回值是迭代的结果。

对于给定的迭代算法，编写不动点迭代函数为<code>IterPoint(x0,func,Iter_inf,err_inf)</code>，其中参数含义分别为：
1. <code>x0</code>代表迭代的初始值。
2. <code>func</code>代表选用的迭代函数。
3. <code>Iter_inf</code>代表迭代次数的上限值，用于判断算法是否发散。
4. <code>err_inf</code>代表迭代时误差的上限值，用于判断算法是否收敛。

最后，进行迭代实验，并做出图像。

## 编程实现

迭代函数实现如下，返回值为迭代的结果。

```matlab
function [y]=f1(x)
    y=(x^2+2)/3;
end
function [y]=f2(x)
    y=sqrt(3*x-2);
end
function [y]=f3(x)
    y=3-2/x;
end
function [y]=f4(x)
    y=(x^2-2)/(2*x-3);
end
```

不动点迭代函数实现如下。为了方便做出收敛次数的图像，函数的返回值为达到收敛时的迭代次数。

```matlab
function [y]=IterPoint(x0,func,Iter_inf,err_inf)
    xi=x0;
    fprintf('X0 : %16.14f\n',x0);
    fxi=func(xi);
    fprintf('Iter 1 : %16.14f\n',fxi);
    xi=fxi;
    Iter=1;
    while(Iter_inf>Iter)
        fxi=func(xi);
        err=abs(fxi-xi);
        xi=fxi;
        Iter=Iter+1;
        fprintf('Iter %2.0d : %16.14f\n',Iter,fxi);
        if(err<err_inf)
            break;
        end
    end
    y=Iter;
end
```

最后，利用上面的函数对给定的四个算法进行实验，并将结果作图展示如下。

```matlab
x=(1.6:0.1:2.5);
Iter_times=zeros(10,1);
for i=1:10
    xi=x(i);
    Iter_times(i)=IterPoint(xi,@f1,1000,1e-5);
end
max_Iter=max(Iter_times);
if(max_Iter!=1000)
    plot(x,Iter_times,'y');
    hold on;
end
for i=1:10
    xi=x(i);
    Iter_times(i)=IterPoint(xi,@f2,1000,1e-5);
end
max_Iter=max(Iter_times);
if(max_Iter!=1000)
    plot(x,Iter_times,'g');
    hold on;
end
for i=1:10
    xi=x(i);
    Iter_times(i)=IterPoint(xi,@f3,1000,1e-5);
end
max_Iter=max(Iter_times);
if(max_Iter!=1000)
    plot(x,Iter_times,'b');
    hold on;
end
for i=1:10
    xi=x(i);
    Iter_times(i)=IterPoint(xi,@f4,1000,1e-5);
end
max_Iter=max(Iter_times);
if(max_Iter!=1000)
    plot(x,Iter_times,'r');
    hold on;
end
xlabel('xi');
ylabel('Iter_times');
title('exp3-t1');
ylim([0 50]);
xlim([1.6 2.5]);
grid on;
```

## 计算结果

在实验中，我选取了<code>Iter_inf=1000,err_inf=1e-5</code>：
1. 当误差小于<code>1e-5</code>时，表示结果已经收敛。
2. 当迭代次数大于<code>1000</code>后仍未收敛，认为其发散。

## 实验结果及思考

可以看出，对于算法2,3,4在给定的区间是收敛的，而算法1发散，即给定的收敛性预测正确。

同时，图像还表明了算法之间的优劣关系：迭代次数越少的算法，可以认为其更优。那么应当有算法4优于算法3优于算法2。

通过实验，我对于不动点迭代有了更好的认识。在迭代之前，应当通过收敛性定理判断给定迭代算法的收敛性。同时，收敛的算法之间同样有优劣性：能够更快速收敛的算法，显然优于其他的算法。