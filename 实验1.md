## 实验内容

实验内容如下：
1. 保留4位有效数字，给出 $I_n=\int_{0}^{1}x^ne^{n-1}\mathrm{d}x$ 的误差估计式。
2. 其中 $I_0$ 可由 $I_n=1-nI_{n-1}$ 推出，即 $I_0=1-e^{-1}$ 。首先用Octave实现上式的递推过程，之后再实现4位十进制数的程序实现（意思是在计算过程中保留只四位有效数字）。
3. Octave的计算精度为15位，因此前者可以看作是后者舍入之前的精确值，比较两者之间的误差是否与你给出的误差估计式相符。

## 实验设计

对递推式进行误差分析，可以得到误差估计式如下：
1. 递推式1中的误差为 $e^{*}(1-nI_{n-1})=-ne^{*}(I_{n-1})$ ，相当于放大了误差。
2. 递推式2中的误差为 $e^{*}(\frac{1-I_n}{n})=-\frac{1}{n}e^{*}(I_n)$ ，相当于缩小了误差。

为了实现上面的递推式，首先，我定义了函数<code>formula_1(n)</code>来模拟4位十进制数的计算，即实现递推式 $I_n=1-nI_{n-1}$ 。

随后，我还定义了函数<code>formula_2(n)</code>来模拟4位十进制数的计算，用于实现递推式 $I_{n-1}=\frac{1-I_n}{n}$ 。上面两个函数的计算结果与真实值作比较，即可计算出误差。

## 编程实现

````matlab
function result = formula_1(n)
    if n == 0
        result = 0.6321;
    else
        result = round((1 - n * formula_1(n - 1)) * 10000) / 10000;
    end
end
function result = formula_2(n)
    if n == 7
        result = 0.1124;
    else
        result = round((1 - formula_2(n + 1)) / (n + 1) * 10000) / 10000;
    end
end
````

在上面的程序中，我使用<code>round(x)</code>函数来实现模拟4位十进制数的运算。

首先将结果乘10000，进行四舍五入后再除10000，即可实现保留4位小数。

## 计算结果

|$I_0$|$I_1$|$I_2$|$I_3$|$I_4$|$I_5$|$I_6$|$I_7$|
|-|-|-|-|-|-|-|-|
|0.6321|0.3679|0.2642|0.2074|0.1704|0.1480|0.1120|0.2160|
|0.6321|0.3679|0.2642|0.2073|0.1709|0.1456|0.1268|0.1124|
|0.6321|0.3679|0.2642|0.2073|0.1709|0.1456|0.1268|0.1124|

对误差进行检验如下：
1. $e^{*}(I_{7})=0.1036=-7\times -0.0148=e^{*}(I_{6})$
2. $e^{*}(I_{6})=-0.0148=-6\times 0.0024=e^{*}(I_{5})$
3. $e^{*}(I_{5})=0.0024=-5\times -0.0005=e^{*}(I_{4})$
4. $e^{*}(I_{4})=-0.0005=-4\times -0.0001=e^{*}(I_{3})$

经检验有 $e^{*}(1-nI_{n-1})=-ne^{*}(I_{n-1})$ 成立，也即误差估计式正确。

## 实验结果及思考

可以看出：使用递推式1的误差较大，而递推式2的误差较小。

这种情况的原因是：递推式1当n逐渐增大时，这种计算方法的舍入误差被乘以系数n，得到了放大。反之，在递推式2中，其舍入误差被除以系数n，得到了控制。

通过实验，我明确了在实际应用中，控制误差传播的重要性。算法的设计也需要考虑到误差的控制。在计算时应当选择误差较小的方式。